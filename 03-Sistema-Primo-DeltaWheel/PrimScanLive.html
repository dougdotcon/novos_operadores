<!doctype html>
	<!--
PrimeSystemApp_DeltaWheel Copyright (c) 2025 Jeanette Leue hexa-primar.de

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is furnished
to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
-->
<meta charset="utf-8">
<title>PrimaScanLive · Δ memoryless · TRUE Turbo (Workers)</title>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<style>
  html,body{margin:0;height:100%;background:#0b1120;color:#e2e8f0;font:14px system-ui}
  .hud{position:fixed;left:12px;top:12px;background:rgba(2,6,23,.85);border:1px solid #334155;padding:10px 12px;border-radius:10px;z-index:9}
  .controls{position:fixed;right:12px;top:12px;background:rgba(2,6,23,.85);border:1px solid #334155;padding:10px 12px;border-radius:10px;z-index:9;display:flex;gap:8px;flex-wrap:wrap}
  .panel{position:fixed;left:12px;bottom:12px;background:rgba(2,6,23,.9);border:1px solid #334155;border-radius:10px;padding:8px;z-index:9;max-width:min(560px,94vw)}
  .btn{cursor:pointer;border:0;border-radius:8px;padding:6px 9px;background:#1f2937;color:#fff}
  .pill{display:inline-block;padding:2px 6px;border-radius:999px;background:#0f172a;border:1px solid #334155;font-size:12px}
  select,input{background:#0f172a;color:#e2e8f0;border:1px solid #334155;border-radius:8px;padding:6px 8px}
  .mono{font:12px ui-monospace,monospace}
</style>

<div class="hud" id="hud">
  <div><b>Δ-Operator</b> · memoryless · <span class="pill" id="wheelLbl">Wheel 30</span></div>
  <div>workers: <span id="wcount">0</span> · total rate: <span id="rate">0</span> p/s</div>
  <div>n≈ <span id="n">—</span> · π(x)= <span id="pc">0</span> · θ(x)= <span id="theta">0</span></div>
  <div>last: <span id="last">—</span></div>
</div>

<div class="controls">
  <label>Workers
    <select id="workers">
      <option>1</option><option>2</option><option selected>4</option><option>6</option><option>8</option>
    </select>
  </label>
  <label>Wheel
    <select id="wheel">
      <option value="30" selected>30</option>
      <option value="210">210</option>
    </select>
  </label>
  <button class="btn" id="start">Start</button>
  <button class="btn" id="stop">Stop</button>
  <button class="btn" id="reset">Reset</button>
</div>

<div class="panel">
  <div style="font-weight:700;margin-bottom:6px">Last 10 primes (live, prüfbar)</div>
  <div id="last10" class="mono">—</div>
</div>

<script>
(()=>{
  // --- Worker-Quelltext als Blob (eine Datei genügt)
  const workerCode = `
  let G30 = [6,4,2,4,2,4,6,2];
  // residues für 210 (2*3*5*7): 48 Stück – wir generieren Gaps einmalig:
  const RES210 = (()=>{ const a=[]; for(let r=1;r<210;r+=2){ if(r%3&&r%5&&r%7) a.push(r); } return a; })();
  const G210 = (()=>{ const a=[]; for(let i=0;i<RES210.length;i++){ const r=RES210[i], s=RES210[(i+1)%RES210.length]; a.push((s-r+210)%210||210); } return a; })();

  function isPrimeStateless(x, wheel){
    if(x<2) return false;
    for (const p of [2,3,5,7]) { if(x===p) return true; if(x%p===0) return false; }
    const limit = Math.floor(Math.sqrt(x));
    if (wheel===210){
      // Divisoren im 210-Wheel: start bei 11
      let d = 11, idx = RES210.indexOf(11);
      while (d<=limit){ if(x%d===0) return false; idx=(idx+1)%G210.length; d += G210[idx]; }
      return true;
    } else {
      // 30-Wheel: start bei 7
      let d = 7, idx = 1;
      while (d<=limit){ if(x%d===0) return false; idx=(idx+1)&7; d += G30[idx]; }
      return true;
    }
  }

  let running=false, wheel=30, blockStart=31, stepIndex=0, gi=0;
  let pc=0, theta=0, lastPrime=0;
  let rateCount=0, lastTS=Date.now();

  function alignToWheel(n, wheel){
    if (n<2) return 2;
    let c = (n%2===0)? n+1 : n;
    if (wheel===210){
      while(!(c%3&&c%5&&c%7)) c+=2;
      gi = RES210.indexOf(c%210); if (gi<0) gi=0;
      return c;
    } else {
      const ok = new Set([1,7,11,13,17,19,23,29]);
      while(!ok.has(c%30)) c+=2;
      // finde index passend zu Restklasse (brutal, reicht 8 Schritte)
      let t=1, idx=0;
      for (let i=0;i<8;i++){ if (t === c%30){ gi=i; break; } t=(t+G30[i])%30; }
      return c;
    }
  }

  function tickBlock(){
    // Feste Rechenlast pro Runde (echter Durchsatz): z.B. 2e5 Kandidaten
    const QUOTA = 200000;
    const G = (wheel===210)? G210 : G30;
    let n = blockStart, localCount=0;
    for (let k=0;k<QUOTA;k++){
      if (isPrimeStateless(n, wheel)){ pc++; theta += Math.log(n); lastPrime = n; rateCount++; localCount++; }
      gi = (gi+1) % G.length; n += G[gi];
      if (n<31) n=31;
    }
    blockStart = n;
    // Rate pro Sekunde an MCU melden
    const now = Date.now();
    if (now - lastTS >= 1000){
      postMessage({type:'rate', rate: rateCount});
      rateCount=0; lastTS=now;
    }
    // Status/Chunk-Ergebnis melden (n, pc, theta, lastPrime)
    postMessage({type:'chunk', n:blockStart, pc, theta, lastPrime});
    if (running) setTimeout(tickBlock,0);
  }

  onmessage = (e)=>{
    const m = e.data;
    if (m.type==='start'){
      wheel = m.wheel|0;
      blockStart = alignToWheel(m.startN|0, wheel);
      gi = 0; running=true; setTimeout(tickBlock,0);
    } else if (m.type==='stop'){ running=false; }
    else if (m.type==='reset'){
      running=false; wheel=30; blockStart=31; gi=0; pc=0; theta=0; lastPrime=0; rateCount=0; lastTS=Date.now();
    }
  };
  `;
  const workerURL = URL.createObjectURL(new Blob([workerCode], {type:'text/javascript'}));

  // --- Hauptseite: Worker-Management
  let workers=[], agg = {pc:0, theta:0, last:0, rate:0, n:0};
  let last10=[];
  let running=false;

  const el = (id)=>document.getElementById(id);
  function fmt(x){ return (typeof x==='number' ? x : 0).toLocaleString('de-DE'); }

  function start(){
    stop();
    const W = parseInt(el('workers').value,10);
    const wheel = parseInt(el('wheel').value,10);
    const baseStart = 31; // alle starten nah beieinander, divergenz durch Gaps
    workers = [];
    agg = {pc:0, theta:0, last:0, rate:0, n:baseStart};
    last10.length=0;
    for (let i=0;i<W;i++){
      const w = new Worker(workerURL);
      w.onmessage = (ev)=>{
        const m = ev.data;
        if (m.type==='rate'){ agg.rate += m.rate; }
        else if (m.type==='chunk'){
          // aggregate
          agg.pc = Math.max(agg.pc, m.pc); // konservativ anzeigen (oder Summe – hier Anzeigezweck)
          agg.theta = Math.max(agg.theta, m.theta);
          agg.last = Math.max(agg.last, m.lastPrime);
          agg.n = Math.max(agg.n, m.n);
          // last10 (nur von dem Worker, der neue last liefert)
          if (m.lastPrime && (last10.length===0 || m.lastPrime>last10[last10.length-1])){
            last10.push(m.lastPrime); while(last10.length>10) last10.shift();
          }
        }
      };
      // leicht versetzter Start verhindert Gleichlauf
      const startN = baseStart + i*1001;
      w.postMessage({type:'start', wheel, startN});
      workers.push(w);
    }
    running=true; updateHUD();
  }

  function stop(){
    for (const w of workers){ try{ w.postMessage({type:'stop'}); w.terminate(); }catch{} }
    workers.length=0; running=false;
  }

  function resetAll(){
    stop();
    agg={pc:0,theta:0,last:0,rate:0,n:0}; last10.length=0;
    el('rate').textContent='0'; el('pc').textContent='0'; el('theta').textContent='0';
    el('n').textContent='—'; el('last').textContent='—'; el('wcount').textContent='0';
    el('last10').textContent='—';
  }

  function updateHUD(){
    if (!running) return;
    // zeige Workerzahl & Rate und Aggregates
    el('wcount').textContent = workers.length.toString();
    el('rate').textContent = Math.round(agg.rate).toLocaleString('de-DE');
    el('pc').textContent = fmt(agg.pc);
    el('theta').textContent = agg.theta.toFixed(0);
    el('n').textContent = fmt(agg.n);
    el('last').textContent = last10.length? fmt(last10[last10.length-1]) : '—';
    // last10 ausgeben
    el('last10').innerHTML = last10.length? (last10.join(', ') + '<br>θ(last10)= ' + last10.reduce((a,b)=>a+Math.log(b),0).toFixed(6)) : '—';
    // Rate zurücksetzen fürs nächste Sek-Fenster
    agg.rate = 0;
    setTimeout(updateHUD, 1000);
  }

  // UI
  el('start').onclick = ()=>{
    el('wheelLbl').textContent = 'Wheel ' + el('wheel').value;
    start();
  };
  el('stop').onclick = stop;
  el('reset').onclick = resetAll;
})();
</script>